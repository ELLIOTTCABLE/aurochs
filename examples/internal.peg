left_comment ::= "(*";
right_comment ::= "*)";
comment ::= left_comment ((comment | ((~ right_comment) sigma)))* right_comment;
space ::= (comment | [ \t\n\r])*;
alpha ::= [a-zA-Z];
decimal ::= [0-9];
bracketed_escape ::= '\\' [nrtb\\\-\[\]];
char_escape ::= '\\' [nrtb'\\];
string_escape ::= '\\' [nrtb"\\];
core_ident ::= (alpha | '_') ((alpha | decimal | '_'))*;
ident ::= space name:core_ident space;
op_sigma ::= space "sigma" space;
op_epsilon ::= space "epsilon" space;
op_eof ::= space "EOF" space;
op_or ::= space '|' space;
op_and ::= space '&' space;
op_not ::= space '~' space;
op_star ::= space '*' space;
op_plus ::= space '+' space;
op_option ::= space '?' space;
op_produces ::= space "::=" space;
op_colon ::= space ':' space;
op_semicolon ::= space ';' space;
op_l_bracket ::= space '[' (~ '^');
op_l_n_bracket ::= space '[' '^';
op_r_bracket ::= ']' space;
op_l_paren ::= space '(' space;
op_r_paren ::= space ')' space;
op_l_brace ::= space '{' space;
op_r_brace ::= space '}' space;
opening_tag ::= space ('<' open:core_ident '>') space;
closing_tag ::= space ("</" close:core_ident '>') space;
expr ::= <Or>sequencable op_or expr</Or> | <And>suffixable_expr op_and expr</And> | sequencable;
sequencable ::= <S>suffixable_expr sequencable</S> | suffixable_expr;
suffixable_expr ::= <Option>simple_expr op_option</Option> | <Plus>simple_expr op_plus</Plus> | <Star>simple_expr op_star</Star> | <Not>op_not suffixable_expr</Not> | simple_expr;
simple_expr ::= (op_l_paren expr op_r_paren) | <Build>opening_tag expr closing_tag</Build> | <Tokenize>op_l_brace expr op_r_brace</Tokenize> | <Epsilon>op_epsilon</Epsilon> | <EOF>op_eof</EOF> | <Sigma>op_sigma</Sigma> | <Ascribe>ident op_colon suffixable_expr</Ascribe> | <String>space ('"' value:(((~ '"') (string_escape | [^"])))* '"') space</String> | <Char>space ('\'' value:(char_escape | ((~ char_escape) sigma)) '\'') space</Char> | <N>ident</N> | characters;
bracketed_char_spec ::= <Range>low:char_spec '-' high:char_spec</Range> | <Char>value:char_spec</Char>;
char_spec ::= bracketed_escape | [^\[\\\-\]\n\t\r\b];
characters ::= <Chars>op_l_bracket bracketed_char_spec* op_r_bracket</Chars> | <NotChars>op_l_n_bracket bracketed_char_spec* op_r_bracket</NotChars>;
production ::= <Production>ident op_produces expr op_semicolon</Production>;
grammar ::= <Grammar>production+</Grammar>;
start ::= grammar;
