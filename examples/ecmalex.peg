(* Ecmascript grammar *)

space ::=
   [ \n\r\t]
 | "<!--"
 | "//" [^\n]* '\n'
 | "/*" ((~ "*/") sigma)* "*/"
;

integer ::= value:('0' | [1-9][0-9]*);
float ::= value:(('0' | [1-9][0-9]* )? '.' [0-9]+);

alphanum ::= [A-Za-z_0-9$]; (* Check lexical rules for identifiers *)
alpha ::= [A-Za-z_$];

quote_string_escape ::= '\\' [bfnrtv'\\];
quote_string ::= ('\'' value:(((~ '\'') (quote_string_escape | [^'])))* '\'');

double_quote_string_escape ::= '\\' [bfnrtv"\\];
double_quote_string ::= ('"' value:(((~ '"') (double_quote_string_escape | [^"])))* '"');

string ::= quote_string | double_quote_string;

regexp ::= '/'body:(regexp_inner*)'/'(options:regexp_option+)?;

regexp_option ::= [giwm];
regexp_escape ::= '\\' sigma;
regexp_inner ::= (regexp_escape | [^/\\\n]);

numeric ::= float | integer;

sp ::= space+ | ~alpha | BOF;

LBRACE ::= "{";
RBRACE ::= "}";
LPAR ::= "(";
RPAR ::= ")";
LBRACK ::= "[";
RBRACK ::= "]";
DOT ::= ".";
DOTCOM ::= ";";
COMMA ::= ",";
L ::= "<";
R ::= ">";
LEQ ::= "<=";
REQ ::= ">=";
EQEQ ::= "==";
NOTEQ ::= "!=";
EQEQEQ ::= "===";
NOTEQEQ ::= "!==";
PLUS ::= "+";
MINUS ::= "-";
TIMES ::= "*";
MOD ::= "%";
PLUSPLUS ::= "++";
MINUSMINUS ::= "--";
LL ::= "<<";
RR ::= ">>";
RRR ::= ">>>";
AND ::= "&";
OR ::= "|";
HAT ::= "^";
BANG ::= "!";
TILDE ::= "~";
ANDAND ::= "&&";
OROR ::= "||";
QUESTION ::= "?";
DOTDOT ::= ":";
EQ ::= "=";
PLUSEQ ::= "+=";
MINUSEQ ::= "-=";
TIMESEQ ::= "*=";
MODEQ ::= "%=";
LLEQ ::= "<<=";
RREQ ::= ">>=";
RRREQ ::= ">>>=";
ANDEQ ::= "&=";
OREQ ::= "|=";
HATEQ ::= "^=";
DIV ::= "/";
DIVEQ ::= "/=";

suffixing sp do
  ABSTRACT ::= "abstract";
  BOOLEAN ::= "boolean";
  BREAK ::= "break";
  BYTE ::= "byte";
  CASE ::= "case";
  CATCH ::= "catch";
  CHAR ::= "char";
  CLASS ::= "class";
  CONST ::= "const";
  CONTINUE ::= "continue";
  DEBUGGER ::= "debugger";
  DEFAULT ::= "default";
  DELETE ::= "delete";
  DO ::= "do";
  DOUBLE ::= "double";
  ELSE ::= "else";
  ENUM ::= "enum";
  EXPORT ::= "export";
  EXTENDS ::= "extends";
  FALSE ::= "false";
  FINAL ::= "final";
  FINALLY ::= "finally";
  FLOAT ::= "float";
  FOR ::= "for";
  FUNCTION ::= "function";
  GOTO ::= "goto";
  IF ::= "if";
  IMPLEMENTS ::= "implements";
  IMPORT ::= "import";
  IN ::= "in";
  INSTANCEOF ::= "instanceof";
  INTERFACE ::= "interface";
  INT ::= "int";
  LONG ::= "long";
  NATIVE ::= "native";
  NEW ::= "new";
  NULL ::= "null";
  PACKAGE ::= "package";
  PRIVATE ::= "private";
  PROTECTED ::= "protected";
  PUBLIC ::= "public";
  RETURN ::= "return";
  SHORT ::= "short";
  STATIC ::= "static";
  SUPER ::= "super";
  SWITCH ::= "switch";
  SYNCHRONIZED ::= "synchronized";
  THIS ::= "this";
  THROWS ::= "throws";
  THROW ::= "throw";
  TRANSIENT ::= "transient";
  TRUE ::= "true";
  TRY ::= "try";
  TYPEOF ::= "typeof";
  UNDEFINED ::= "undefined";
  VAR ::= "var";
  VOID ::= "void";
  VOLATILE ::= "volatile";
  WHILE ::= "while";
  WITH ::= "with";
done;

keyword ::=
  "abstract"
| "break"
| "boolean"
| "byte"
| "case"
| "catch"
| "char"
| "class"
| "const"
| "continue"
| "debugger"
| "default"
| "delete"
| "do"
| "double"
| "else"
| "enum"
| "export"
| "extends"
| "false"
| "final"
| "finally"
| "float"
| "for"
| "function"
| "goto"
| "if"
| "implements"
| "import"
| "in"
| "instanceof"
| "int"
| "interface"
| "long"
| "native"
| "new"
| "null"
| "package"
| "private"
| "protected"
| "public"
| "return"
| "short"
| "static"
| "super"
| "switch"
| "synchronized"
| "this"
| "throw"
| "throws"
| "transient"
| "true"
| "try"
| "typeof"
| "undefined"
| "var"
| "void"
| "volatile"
| "while"
| "with"
;

IDENTIFIER ::= ~(keyword sp) alpha alphanum*;

optional_space ::= space*;

outfixing optional_space do
  appending optional_space do
    program ::= token*;

    token ::=
      litteral
    | <LBRACE/>LBRACE
    | <RBRACE/>RBRACE
    | <LPAR/>LPAR
    | <RPAR/>RPAR
    | <LBRACK/>LBRACK
    | <RBRACK/>RBRACK
    | <DOT/>DOT
    | <DOTCOM/>DOTCOM
    | <COMMA/>COMMA
    | <L/>L
    | <R/>R
    | <LEQ/>LEQ
    | <REQ/>REQ
    | <EQEQ/>EQEQ
    | <NOTEQ/>NOTEQ
    | <EQEQEQ/>EQEQEQ
    | <NOTEQEQ/>NOTEQEQ
    | <PLUS/>PLUS
    | <MINUS/>MINUS
    | <TIMES/>TIMES
    | <MOD/>MOD
    | <PLUSPLUS/>PLUSPLUS
    | <MINUSMINUS/>MINUSMINUS
    | <LL/>LL
    | <RR/>RR
    | <RRR/>RRR
    | <AND/>AND
    | <OR/>OR
    | <HAT/>HAT
    | <BANG/>BANG
    | <TILDE/>TILDE
    | <ANDAND/>ANDAND
    | <OROR/>OROR
    | <QUESTION/>QUESTION
    | <DOTDOT/>DOTDOT
    | <EQ/>EQ
    | <PLUSEQ/>PLUSEQ
    | <MINUSEQ/>MINUSEQ
    | <TIMESEQ/>TIMESEQ
    | <MODEQ/>MODEQ
    | <LLEQ/>LLEQ
    | <RREQ/>RREQ
    | <RRREQ/>RRREQ
    | <ANDEQ/>ANDEQ
    | <OREQ/>OREQ
    | <HATEQ/>HATEQ
    | <DIVEQ/>DIVEQ
    | <DIV/>DIV
    | <ABSTRACT/>ABSTRACT
    | <BOOLEAN/>BOOLEAN
    | <BREAK/>BREAK
    | <BYTE/>BYTE
    | <CASE/>CASE
    | <CATCH/>CATCH
    | <CHAR/>CHAR
    | <CLASS/>CLASS
    | <CONST/>CONST
    | <CONTINUE/>CONTINUE
    | <DEBUGGER/>DEBUGGER
    | <DEFAULT/>DEFAULT
    | <DELETE/>DELETE
    | <DO/>DO
    | <DOUBLE/>DOUBLE
    | <ELSE/>ELSE
    | <ENUM/>ENUM
    | <EXPORT/>EXPORT
    | <EXTENDS/>EXTENDS
    | <FALSE/>FALSE
    | <FINAL/>FINAL
    | <FINALLY/>FINALLY
    | <FLOAT/>FLOAT
    | <FOR/>FOR
    | <FUNCTION/>FUNCTION
    | <GOTO/>GOTO
    | <IF/>IF
    | <IMPLEMENTS/>IMPLEMENTS
    | <IMPORT/>IMPORT
    | <IN/>IN
    | <INSTANCEOF/>INSTANCEOF
    | <INTERFACE/>INTERFACE
    | <INT/>INT
    | <LONG/>LONG
    | <NATIVE/>NATIVE
    | <NEW/>NEW
    | <NULL/>NULL
    | <PACKAGE/>PACKAGE
    | <PRIVATE/>PRIVATE
    | <PROTECTED/>PROTECTED
    | <PUBLIC/>PUBLIC
    | <RETURN/>RETURN
    | <SHORT/>SHORT
    | <STATIC/>STATIC
    | <SUPER/>SUPER
    | <SWITCH/>SWITCH
    | <SYNCHRONIZED/>SYNCHRONIZED
    | <THIS/>THIS
    | <THROWS/>THROWS
    | <THROW/>THROW
    | <TRANSIENT/>TRANSIENT
    | <TRUE/>TRUE
    | <TRY/>TRY
    | <TYPEOF/>TYPEOF
    | <UNDEFINED/>UNDEFINED
    | <VAR/>VAR
    | <VOID/>VOID
    | <VOLATILE/>VOLATILE
    | <WHILE/>WHILE
    | <WITH/>WITH
    | <Ident>name:IDENTIFIER</Ident>
    ;

    numeric_litteral ::=
      <Float>float</Float>
    | <Integer>integer</Integer>
    ;

    litteral ::=
      numeric_litteral
    | <String>string</String>
    | <Regexp>regexp</Regexp>
    | <True/>TRUE
    | <False/>FALSE
    | <Null/>NULL
    | <Undefined/>UNDEFINED
    ;
  done;
done;

start ::= program space* EOF;
